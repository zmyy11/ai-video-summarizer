import os
import time
from typing import Optional, Dict
from src.config import settings
from src.utils.logger import logger

def parse_cookie_string(cookie_str: str, domain: str) -> str:
    """
    Parse a cookie string (key=value; key2=value2) into Netscape format content.
    """
    if not cookie_str:
        return ""
        
    lines = [
        "# Netscape HTTP Cookie File",
        "# This file is generated by ai-video-summarizer",
        "# http://curl.haxx.se/rfc/cookie_format.html",
        ""
    ]
    
    # Simple parsing: split by ';'
    parts = [p.strip() for p in cookie_str.split(';') if p.strip()]
    
    # Expiry: Set to a future timestamp (e.g., +1 year)
    expiry = int(time.time()) + 31536000
    
    for part in parts:
        if '=' not in part:
            continue
        name, value = part.split('=', 1)
        
        # Netscape format: domain, flag, path, secure, expiration, name, value
        # flag: TRUE if domain starts with ., FALSE otherwise
        flag = "TRUE" if domain.startswith(".") else "FALSE"
        
        line = f"{domain}\t{flag}\t/\tFALSE\t{expiry}\t{name}\t{value}"
        lines.append(line)
        
    return "\n".join(lines)

def load_netscape_cookies_as_dict(cookies_path: str, domain_contains: str) -> Dict[str, str]:
    if not cookies_path or not os.path.exists(cookies_path):
        return {}
    now = int(time.time())
    cookies: Dict[str, str] = {}
    with open(cookies_path, "r", encoding="utf-8", errors="ignore") as f:
        for raw in f:
            line = raw.strip()
            if not line or line.startswith("#"):
                continue
            parts = line.split("\t")
            if len(parts) < 7:
                continue
            domain, _flag, _path, _secure, expiry_s, name, value = parts[:7]
            if domain_contains not in (domain or ""):
                continue
            try:
                expiry = int(expiry_s)
            except Exception:
                expiry = 0
            if expiry and expiry < now:
                continue
            cookies[name] = value
    return cookies

def ensure_cookies_file(platform: str) -> Optional[str]:
    """
    Ensure a cookies.txt file exists for the given platform.
    If settings.COOKIES_PATH is set, return it.
    Otherwise, generate from env vars if available.
    """
    # 1. User provided file takes precedence
    if settings.COOKIES_PATH and os.path.exists(settings.COOKIES_PATH):
        return settings.COOKIES_PATH

    # 2. Check for Env Vars
    cookie_content = ""
    domain = ""
    
    if platform == "bilibili" and settings.BILIBILI_COOKIES:
        domain = ".bilibili.com"
        cookie_content = parse_cookie_string(settings.BILIBILI_COOKIES, domain)
    elif platform == "youtube" and settings.YOUTUBE_COOKIES:
        domain = ".youtube.com"
        cookie_content = parse_cookie_string(settings.YOUTUBE_COOKIES, domain)
    
    if cookie_content:
        # Create a temp file in cache dir
        cache_dir = settings.CACHE_DIR
        os.makedirs(cache_dir, exist_ok=True)
        
        # We append both domains to a single file if needed, or separate?
        # For simplicity, let's make a combined file if both exist, or specific one.
        # Actually, let's make a "generated_cookies.txt"
        
        # But wait, if we call this for bilibili, we might overwrite youtube?
        # Better to have one single generated file.
        
        generated_path = os.path.join(cache_dir, "generated_cookies.txt")
        
        # Read existing generated content to merge? 
        # For now, let's just regenerate everything we have in env.
        
        all_lines = [
            "# Netscape HTTP Cookie File",
            "# This file is generated by ai-video-summarizer",
            ""
        ]
        
        if settings.BILIBILI_COOKIES:
            all_lines.append(parse_cookie_string(settings.BILIBILI_COOKIES, ".bilibili.com"))
        
        if settings.YOUTUBE_COOKIES:
            all_lines.append(parse_cookie_string(settings.YOUTUBE_COOKIES, ".youtube.com"))
            
        with open(generated_path, "w", encoding="utf-8") as f:
            f.write("\n".join(all_lines))
            
        logger.info(f"Generated cookies.txt from environment variables at {generated_path}")
        return generated_path
        
    return None
